================================================================================
FIL: sponsor_match/ui/styles.py
================================================================================

import streamlit as st


def apply_professional_styles():
    """Apply professional styling to Streamlit app."""
    css = """
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    /* Main app styling */
    .main .block-container {
        font-family: 'Inter', sans-serif;
        padding-top: 1rem;
        padding-bottom: 2rem;
        max-width: 1200px;
    }

    /* Header styling */
    h1 {
        color: #1e40af !important;
        font-weight: 700 !important;
        margin-bottom: 2rem !important;
    }

    h2 {
        color: #1e40af !important;
        font-weight: 600 !important;
        margin-bottom: 1.5rem !important;
    }

    /* Button styling */
    .stButton > button {
        background-color: #2563eb;
        color: white;
        border-radius: 8px;
        font-weight: 500;
        border: none;
        padding: 0.5rem 1rem;
        transition: all 0.2s ease;
    }

    .stButton > button:hover {
        background-color: #1d4ed8;
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
        transform: translateY(-1px);
    }

    /* Metric cards */
    [data-testid="metric-container"] {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    /* Sidebar styling */
    .css-1d391kg {
        background-color: #f8fafc;
    }

    /* Input fields */
    .stTextInput > div > div > input {
        border-radius: 6px;
        border: 1px solid #d1d5db;
    }

    .stTextInput > div > div > input:focus {
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    /* Success/Error styling */
    .stSuccess {
        background-color: #f0f9ff;
        border-left: 4px solid #10b981;
    }

    .stError {
        background-color: #fef2f2;
        border-left: 4px solid #ef4444;
    }
    </style>
    """
    st.markdown(css, unsafe_allow_html=True)


def create_metric_card(title, value, delta=None):
    """Create a styled metric card."""
    delta_html = ""
    if delta:
        color = "#10b981" if delta > 0 else "#ef4444"
        arrow = "↗" if delta > 0 else "↘"
        delta_html = f"""
        <div style="color: {color}; font-size: 0.875rem; font-weight: 500;">
            {arrow} {abs(delta):.1f}%
        </div>
        """

    return f"""
    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 8px; 
                padding: 1.5rem; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);">
        <div style="color: #6b7280; font-size: 0.875rem; margin-bottom: 0.5rem;">
            {title}
        </div>
        <div style="font-size: 1.875rem; font-weight: 700; color: #111827; margin-bottom: 0.25rem;">
            {value}
        </div>
        {delta_html}
    </div>
    """

================================================================================
FIL: sponsor_match/ui/services/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/services/data_service.py
================================================================================

"""
Data service for handling data loading and initialization.
"""
import logging

import pandas as pd

from sponsor_match.core.db import get_engine
from sponsor_match.ui.utils.sessions import set_session_data

logger = logging.getLogger(__name__)

# Global caches
_engine = None
_clubs_df = None
_companies_df = None


def load_initial_data():
    """
    Load initial data needed by the application.
    This should be called once at startup.
    """
    try:
        # Initialize engine
        global _engine
        _engine = get_engine()
        logger.info("Database engine initialized")

        # Load clubs
        load_clubs()

        # Load only if needed in UI
        # load_companies()

        return True
    except Exception as e:
        logger.error(f"Error loading initial data: {e}")
        return False


def load_clubs():
    """
    Load clubs from database or use fallback data.

    Returns:
        DataFrame of clubs
    """
    global _clubs_df

    # Return cached data if available
    if _clubs_df is not None:
        return _clubs_df

    try:
        if _engine:
            _clubs_df = pd.read_sql("SELECT * FROM clubs", _engine)
            logger.info(f"Loaded {len(_clubs_df)} clubs from database")
            return _clubs_df
    except Exception as e:
        logger.warning(f"Failed to load clubs from database: {e}")

    # Create sample data as fallback
    _clubs_df = pd.DataFrame({
        'id': [1, 2, 3],
        'name': ['IFK Göteborg', 'GAIS', 'BK Häcken'],
        'size_bucket': ['large', 'medium', 'medium'],
        'member_count': [500, 250, 300],
        'lat': [57.7089, 57.6969, 57.7209],
        'lon': [11.9746, 11.9789, 11.9390],
        'address': ['Göteborg', 'Göteborg', 'Göteborg']
    })
    logger.info("Using sample club data")

    return _clubs_df


def load_companies():
    """
    Load companies from database or use fallback data.

    Returns:
        DataFrame of companies
    """
    global _companies_df

    # Return cached data if available
    if _companies_df is not None:
        return _companies_df

    try:
        if _engine:
            _companies_df = pd.read_sql("SELECT * FROM companies", _engine)
            logger.info(f"Loaded {len(_companies_df)} companies from database")
            return _companies_df
    except Exception as e:
        logger.warning(f"Failed to load companies from database: {e}")

    # Create sample data as fallback
    _companies_df = pd.DataFrame([
        {
            "id": 1,
            "name": "Nordic Bank",
            "revenue_ksek": 50000,
            "employees": 120,
            "industry": "Finance",
            "size_bucket": "large",
            "lat": 57.70,
            "lon": 11.97
        },
        {
            "id": 2,
            "name": "Energigruppen AB",
            "revenue_ksek": 25000,
            "employees": 45,
            "industry": "Energy",
            "size_bucket": "medium",
            "lat": 57.71,
            "lon": 11.98
        }
    ])
    logger.info("Using sample company data")

    return _companies_df


def get_club_by_id(club_id):
    """
    Get a club by its ID.

    Args:
        club_id: Club ID to look up

    Returns:
        Club dictionary or None if not found
    """
    # Load clubs if needed
    clubs = load_clubs()

    # Find club by ID
    club_row = clubs[clubs['id'] == club_id]
    if len(club_row) > 0:
        return club_row.iloc[0].to_dict()

    return None


def save_club(club_data):
    """
    Save club data to database.
    This is a placeholder - in a real app, this would update the database.

    Args:
        club_data: Dictionary of club data to save

    Returns:
        True if successful, False otherwise
    """
    # In a real application, this would save to the database
    logger.info(f"Saving club data: {club_data}")

    # For now, just store in session state
    set_session_data("selected_club", club_data)

    # Pretend it was successful
    return True


================================================================================
FIL: sponsor_match/ui/services/search_services.py
================================================================================

from sponsor_match.ml.pipeline import score_and_rank

def recommend_sponsors(club_id: int, club_bucket: str,
                       max_distance: float = 50.0, top_n: int = 10):
    """
    Returns list of {id,name,lat,lon,distance,score} for top_n companies.
    """
    return score_and_rank(
        assoc_id=club_id,
        assoc_bucket=club_bucket,
        max_distance=max_distance,
        top_n=top_n
    )


================================================================================
FIL: sponsor_match/ui/components/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/components/cards.py
================================================================================

"""
Card UI components for SponsorMatch application.
"""
import streamlit as st


def render_info_card(icon, title, text):
    """
    Render an information card with icon, title and text.

    Args:
        icon: Emoji or icon character
        title: Card title
        text: Card description text
    """
    st.markdown(
        f"""
        <div style="background:#eff6ff;border:1px solid #bfdbfe;border-radius:8px;
                    padding:1.5rem;text-align:center;box-shadow:0 1px 2px rgba(0,0,0,0.05);">
          <div style="font-size:2rem;color:#2563eb;margin-bottom:0.5rem;">{icon}</div>
          <div style="font-size:1.125rem;font-weight:600;color:#1e40af;margin-bottom:0.5rem;">{title}</div>
          <div style="font-size:0.875rem;color:#4b5563;">{text}</div>
        </div>
        """,
        unsafe_allow_html=True,
    )


def render_sponsor_card(sponsor):
    """
    Render a sponsor card with company information and contact button.

    Args:
        sponsor: Dictionary containing sponsor information
    """
    # Extract sponsor details, with defaults for missing values
    name = sponsor.get('name', 'Unknown Sponsor')
    description = sponsor.get('description', 'No description available.')
    score = sponsor.get('score', 0)
    revenue = sponsor.get('revenue_ksek', 'N/A')
    employees = sponsor.get('employees', 'N/A')
    industry = sponsor.get('industry', 'N/A')

    # Format score as percentage
    score_display = f"{score:.0%}" if isinstance(score, (int, float)) else "N/A"

    # Create formatted card with all information
    st.markdown(
        f"""
        <div style="background:white;padding:1.5rem;border-radius:8px;
                    box-shadow:0 1px 3px rgba(0,0,0,0.1);margin-bottom:1rem;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
            <div style="font-size:1.125rem;font-weight:700;color:#1e40af;">{name}</div>
            <div style="background:#dbeafe;color:#1e40af;padding:0.25rem 0.5rem;
                        border-radius:9999px;font-size:0.75rem;font-weight:600;">
              {score_display} match
            </div>
          </div>
          <div style="font-size:0.875rem;color:#4b5563;margin-bottom:0.75rem;">{description}</div>
          <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:0.5rem;
                      font-size:0.75rem;color:#6b7280;margin-bottom:1rem;">
            <div>
              <div style="font-weight:600;">Omsättning</div>
              <div>{revenue} tkr</div>
            </div>
            <div>
              <div style="font-weight:600;">Anställda</div>
              <div>{employees}</div>
            </div>
            <div>
              <div style="font-weight:600;">Bransch</div>
              <div>{industry}</div>
            </div>
          </div>
          <div style="display:flex;gap:0.5rem;">
            <button style="flex:1;background:#2563eb;color:white;padding:0.5rem 1rem;
                           border:none;border-radius:4px;font-weight:500;cursor:pointer;">
              📧 Kontakta
            </button>
            <button style="flex:1;background:#f3f4f6;color:#374151;padding:0.5rem 1rem;
                           border:none;border-radius:4px;font-weight:500;cursor:pointer;">
              ℹ️ Detaljer
            </button>
          </div>
        </div>
        """,
        unsafe_allow_html=True,
    )


def render_stat_card(title, value, description=None, trend=None):
    """
    Render a statistic card with optional trend indicator.

    Args:
        title: Stat title
        value: Main value to display
        description: Optional description or context
        trend: Optional trend value (positive or negative number)
    """
    # Determine trend styling
    trend_html = ""
    if trend is not None:
        trend_color = "#10b981" if trend > 0 else "#ef4444"  # Green or red
        trend_arrow = "↑" if trend > 0 else "↓"
        trend_html = f"""
        <div style="color:{trend_color};font-size:0.875rem;font-weight:600;">
          {trend_arrow} {abs(trend):.1f}%
        </div>
        """

    # Description HTML if provided
    desc_html = f"""
    <div style="color:#6b7280;font-size:0.75rem;">
      {description}
    </div>
    """ if description else ""

    # Render the card
    st.markdown(
        f"""
        <div style="background:white;padding:1.25rem;border-radius:8px;
                    box-shadow:0 1px 3px rgba(0,0,0,0.1);height:100%;">
          <div style="color:#6b7280;font-size:0.875rem;margin-bottom:0.5rem;">
            {title}
          </div>
          <div style="display:flex;align-items:baseline;gap:0.5rem;">
            <div style="font-size:1.5rem;font-weight:700;color:#111827;">
              {value}
            </div>
            {trend_html}
          </div>
          {desc_html}
        </div>
        """,
        unsafe_allow_html=True,
    )


================================================================================
FIL: sponsor_match/ui/components/map_view.py
================================================================================

# sponsor_match/ui/components/map_view.py

import streamlit as st
from folium import Map, Marker, Popup, Icon
from folium.plugins import MarkerCluster, HeatMap
from streamlit_folium import st_folium

def render_map(club=None, sponsors=None, height=400, width=None):
    """
    Render an interactive map with club and sponsor markers.

    Args:
        club: Dictionary with club information (optional)
        sponsors: List of sponsor dictionaries (optional)
        height: Map height in pixels (default 400)
        width:  Map width in pixels (optional; omit to auto-size)
    """
    # Default center on Gothenburg
    center = [57.7089, 11.9746]
    if club and club.get('lat') and club.get('lon'):
        center = [club['lat'], club['lon']]

    m = Map(location=center, zoom_start=12, tiles="CartoDB positron")

    # Club marker
    if club and club.get('lat') and club.get('lon'):
        Marker(
            location=[club['lat'], club['lon']],
            popup=Popup(_club_popup(club), max_width=300),
            icon=Icon(color='purple', icon='flag', prefix='fa'),
            tooltip=club.get('name', 'Club')
        ).add_to(m)

    # Sponsor markers
    if sponsors:
        cluster = MarkerCluster().add_to(m)
        heat_data = []
        for sponsor in sponsors:
            if sponsor.get('lat') and sponsor.get('lon'):
                Marker(
                    location=[sponsor['lat'], sponsor['lon']],
                    popup=Popup(_sponsor_popup(sponsor), max_width=300),
                    icon=Icon(color=_marker_color(sponsor), icon='building', prefix='fa'),
                    tooltip=sponsor.get('name', 'Sponsor')
                ).add_to(cluster)
                if sponsor.get('score') is not None:
                    heat_data.append([sponsor['lat'], sponsor['lon'], sponsor['score']])
        if heat_data:
            HeatMap(heat_data).add_to(m)

    # Only pass width if it’s a real integer
    if width:
        return st_folium(m, width=width, height=height)
    else:
        return st_folium(m, height=height)


def _club_popup(club):
    return f"""
    <div style="width:200px">
        <h4>{club.get('name','')}</h4>
        <p><b>Medlemmar:</b> {club.get('member_count','N/A')}</p>
        <p><b>Storlek:</b> {club.get('size_bucket','').title()}</p>
        <p><b>Adress:</b> {club.get('address','N/A')}</p>
    </div>
    """

def _sponsor_popup(sponsor):
    contact = sponsor.get('contact', {})
    return f"""
    <div style="width:200px">
        <h4>{sponsor.get('name','')}</h4>
        <p>{sponsor.get('description','')}</p>
        <p>📧 {contact.get('email','')}</p>
        <p>📞 {contact.get('phone','')}</p>
    </div>
    """

def _marker_color(sponsor):
    score = sponsor.get('score', 0)
    if score >= 75:
        return 'green'
    if score >= 50:
        return 'orange'
    return 'red'


================================================================================
FIL: sponsor_match/ui/components/modals.py
================================================================================

"""
Modal dialog components for SponsorMatch application.
"""
import streamlit as st


def show_login_modal():
    """Show a login modal dialog."""
    # Use Streamlit's experimental modal feature if available
    use_experimental = hasattr(st, "modal")

    if use_experimental:
        with st.modal("Logga in", key="login_modal"):
            _render_login_form()
    else:
        # Fallback to expander
        with st.expander("Logga in", expanded=True):
            _render_login_form()


def show_sponsor_modal(sponsor):
    """
    Show a sponsor details modal dialog.

    Args:
        sponsor: Dictionary with sponsor information
    """
    use_experimental = hasattr(st, "modal")
    title = sponsor.get('name', 'Sponsor')

    if use_experimental:
        with st.modal(title, key="sponsor_modal"):
            _render_sponsor_details(sponsor)
    else:
        # Fallback to expander
        with st.expander(title, expanded=True):
            _render_sponsor_details(sponsor)


def show_confirmation_modal(title, message, confirm_text="Bekräfta", cancel_text="Avbryt"):
    """
    Show a confirmation dialog and return the result.

    Args:
        title: Modal title
        message: Message to display
        confirm_text: Text for confirm button
        cancel_text: Text for cancel button

    Returns:
        True if confirmed, False otherwise
    """
    use_experimental = hasattr(st, "modal")

    if use_experimental:
        with st.modal(title, key="confirm_modal"):
            st.write(message)
            col1, col2 = st.columns(2)
            with col1:
                if st.button(cancel_text, key="modal_cancel"):
                    return False
            with col2:
                if st.button(confirm_text, key="modal_confirm", type="primary"):
                    return True
    else:
        # Fallback to regular UI
        st.write(message)
        col1, col2 = st.columns(2)
        with col1:
            if st.button(cancel_text, key="confirm_cancel"):
                return False
        with col2:
            if st.button(confirm_text, key="confirm_confirm", type="primary"):
                return True

    return False


def _render_login_form():
    """Render login form content."""
    st.text_input("E-post", key="login_email")
    st.text_input("Lösenord", type="password", key="login_password")

    col1, col2 = st.columns(2)
    with col1:
        st.checkbox("Kom ihåg mig", key="remember_me")
    with col2:
        st.markdown(
            "<div style='text-align:right;'><a href='#'>Glömt lösenord?</a></div>",
            unsafe_allow_html=True
        )

    if st.button("Logga in", type="primary", key="do_login"):
        st.success("Inloggning lyckades!")
        return True

    st.markdown("---")
    st.markdown("Har du inget konto? [Registrera dig här](#)")

    return False


def _render_sponsor_details(sponsor):
    """Render sponsor details content."""
    # Extract sponsor details with defaults
    name = sponsor.get('name', 'Unknown Sponsor')
    description = sponsor.get('description', 'No description available.')
    industry = sponsor.get('industry', 'N/A')
    revenue = sponsor.get('revenue_ksek', 'N/A')
    employees = sponsor.get('employees', 'N/A')
    website = sponsor.get('website', '#')
    email = sponsor.get('contact', {}).get('email', 'kontakt@företag.se')
    phone = sponsor.get('contact', {}).get('phone', 'N/A')

    # Display sponsor information
    st.subheader(name)
    st.write(description)

    # Company details
    st.markdown("### Företagsinformation")
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Bransch", industry)
    with col2:
        st.metric("Omsättning", f"{revenue} tkr")
    with col3:
        st.metric("Anställda", employees)

    # Contact information
    st.markdown("### Kontaktuppgifter")
    st.write(f"📧 E-post: {email}")
    st.write(f"📞 Telefon: {phone}")
    if website != '#':
        st.write(f"🌐 [Besök webbplats]({website})")

    # Contact form
    st.markdown("### Skicka meddelande")
    with st.form("contact_form"):
        st.text_area("Meddelande", placeholder="Skriv ditt meddelande här...")
        submitted = st.form_submit_button("Skicka")

        if submitted:
            st.success("Meddelande skickat!")


================================================================================
FIL: sponsor_match/ui/components/sidebar.py
================================================================================

"""
Sidebar component for SponsorMatch application.
"""
import streamlit as st
from sponsor_match.ui.utils.session import clear_session_data


def render_sidebar():
    """Render the application sidebar."""
    with st.sidebar:
        st.title("🏆 SponsorMatch AI")
        st.markdown("Hitta rätt sponsorer för din idrottsförening")
        st.divider()

        # Settings section
        st.subheader("Inställningar")
        api_key = st.text_input("API-nyckel", value="demo-key", type="password")
        st.checkbox("Avancerad matchning", value=True,
                    help="Aktivera AI-baserad matchning")

        # Language selection
        st.selectbox("Språk", ["Svenska", "English"], index=0)

        st.divider()

        # User actions
        if st.button("Rensa sökhistorik"):
            clear_session_data("search_results")
            clear_session_data("search_scores")
            st.success("Sökhistorik rensad!")

        if st.button("Logga ut"):
            clear_session_data()
            st.success("Du har loggats ut.")

        # About section
        st.markdown("### Om SponsorMatch AI")
        st.markdown("""
        SponsorMatch AI hjälper idrottsföreningar att hitta och kontakta lämpliga 
        företag som kan bli sponsorer.

        Vi använder AI för att matcha föreningar med företag baserat på geografi, 
        storlek, bransch och värderingar.
        """)

        st.markdown("Made with ❤️ by Team 14")

        # Version info
        st.caption("Version 1.0.0")


================================================================================
FIL: sponsor_match/ui/utils/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/utils/sessions.py
================================================================================

"""
Utilities for managing Streamlit session state.
"""
import streamlit as st


def get_session_data(key, default=None):
    """
    Get data from session state with fallback to default.

    Args:
        key: Session state key
        default: Default value if key doesn't exist

    Returns:
        Value from session state or default
    """
    return st.session_state.get(key, default)


def set_session_data(key, value):
    """
    Set data in session state.

    Args:
        key: Session state key
        value: Value to store
    """
    st.session_state[key] = value


def clear_session_data(key=None):
    """
    Clear data from session state.

    Args:
        key: Specific key to clear, or None to clear all app-specific keys
    """
    if key is not None and key in st.session_state:
        del st.session_state[key]
    elif key is None:
        # Clear all app-specific keys (doesn't affect Streamlit's internal keys)
        app_keys = [k for k in st.session_state.keys()
                    if not k.startswith('_') and k not in ['formSubmitter', 'formKey']]
        for k in app_keys:
            del st.session_state[k]


================================================================================
FIL: sponsor_match/ui/pages/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/pages/home.py
================================================================================

#!/usr/bin/env python3
"""
sponsor_match/ui/pages/home.py

Home page for SponsorMatch application.
"""

import streamlit as st

def render_home_page():
    """Render the home page with responsive cards."""
    st.markdown(
        "<h2 style='font-size:2rem;font-weight:600;color:var(--primaryColor);'>"
        "Välkommen till SponsorMatch</h2>",
        unsafe_allow_html=True,
    )

    # open the flex container
    st.markdown('<div class="card-container">', unsafe_allow_html=True)

    # each card
    cards = [
        ("✨", "Tips & tricks", "Råd för att locka sponsorer snabbare."),
        ("⚙️", "Inställningar",       "Justera profil, sekretess och synlighet."),
        ("ℹ️", "Om SponsorMatch",     "Så fungerar plattformen och affärsmodellen."),
    ]
    for icon, title, desc in cards:
        st.markdown(
            f"""
            <div class="card">
              <div style="font-size:2rem;color:var(--primaryColor);">{icon}</div>
              <h3 style="margin:0.5rem 0;color:var(--primaryColor);">{title}</h3>
              <p style="margin:0;color:var(--textColor);">{desc}</p>
            </div>
            """,
            unsafe_allow_html=True,
        )

    # close the flex container
    st.markdown('</div>', unsafe_allow_html=True)


================================================================================
FIL: sponsor_match/ui/pages/profile.py
================================================================================

#!/usr/bin/env python3
"""
sponsor_match/ui/pages/profile.py

Streamlit page for managing club profile.
"""

import streamlit as st

# fix: it's session.py, not sessions.py
from sponsor_match.ui.utils.sessions import get_session_data, set_session_data


def render_profile_page():
    st.markdown(
        "<h2 style='font-size:2rem;font-weight:600;color:var(--primaryColor);'>"
        "Min förening</h2>",
        unsafe_allow_html=True,
    )

    # get_session_data() may return None, so we coalesce to a dict
    club = get_session_data("selected_club") or {}

    if club:
        _render_profile_form(club)
    else:
        st.info(
            "Du har inte valt någon förening. "
            "Använd sökfunktionen för att hitta din förening."
        )
        _render_profile_form(None)

    with st.expander("Sponsorhistorik", expanded=False):
        _render_sponsorship_history()

    with st.expander("Inställningar", expanded=False):
        _render_preferences()


def _render_profile_form(club: dict | None = None):
    with st.form("profile_form"):
        # prefill from club dict or fall back to empty strings
        name    = st.text_input("Föreningens namn", value=club.get("name","") if club else "")
        address = st.text_input("Adress",           value=club.get("address","") if club else "")

        # size bucket select
        size_labels = ["Liten", "Medel", "Stor"]
        rev_map     = {"Liten":"small","Medel":"medium","Stor":"large"}
        # figure out which index to preselect
        if club and club.get("size_bucket") in {"small","medium","large"}:
            pre = {"small":"Liten","medium":"Medel","large":"Stor"}[club["size_bucket"]]
            default_idx = size_labels.index(pre)
        else:
            default_idx = 1  # Medel
        size_sel = st.selectbox("Storlek", size_labels, index=default_idx)

        email = st.text_input("E-post",   value=club.get("email","") if club else "")
        phone = st.text_input("Telefon",  value=club.get("phone","") if club else "")
        desc  = st.text_area("Beskrivning", value=club.get("description","") if club else "")

        if st.form_submit_button("Spara profil"):
            st.success("Profilen har sparats!")
            profile = {
                "name":         name,
                "address":      address,
                "size_bucket":  rev_map[size_sel],
                "email":        email,
                "phone":        phone,
                "description":  desc,
            }
            # preserve id + coords if they existed
            if club:
                for key in ("id","latitude","longitude"):
                    if key in club:
                        profile[key] = club[key]
            set_session_data("selected_club", profile)


def _render_sponsorship_history():
    st.markdown("#### Nuvarande sponsorer")
    history = st.session_state.get("sponsors_history", [])
    if history:
        for s in history:
            st.write(f"**{s['name']}** ({s['contract_date']} – {s['end_date']}) • {s['status']}")
            st.write("---")
    else:
        st.write("Inga aktiva sponsoravtal.")


def _render_preferences():
    st.markdown("#### Notifikationsinställningar")
    st.checkbox("E-postaviseringar",   value=True,  key="email_notifications")
    st.checkbox("SMS-aviseringar",      value=False, key="sms_notifications")

    st.markdown("#### Sekretess")
    st.checkbox("Visa förening publikt",      value=True,  key="public_profile")
    st.checkbox("Tillåt kontakt från företag", value=True,  key="allow_contact")

    if st.button("Spara inställningar", key="save_prefs"):
        st.success("Inställningarna har sparats!")


================================================================================
FIL: sponsor_match/ui/pages/search.py
================================================================================

import streamlit as st
import pandas as pd
import folium
from streamlit_folium import st_folium, folium_static, folium_static

from sponsor_match.core.db import get_engine
from sponsor_match.services.service import SponsorMatchService
from sponsor_match.ml.pipeline import score_and_rank


def load_associations_service() -> SponsorMatchService:
    """Get the service instance."""
    try:
        engine = get_engine()
        return SponsorMatchService(engine)
    except Exception as e:
        st.error(f"Database connection error: {e}")
        return None


def search_associations(service: SponsorMatchService, query: str) -> pd.DataFrame:
    """Search for associations using the service."""
    if not service:
        return pd.DataFrame()

    try:
        # Use the service search method
        results = service.search(query)
        # Filter to only associations
        return results[results['type'] == 'association'].copy()
    except Exception as e:
        st.error(f"Search error: {e}")
        return pd.DataFrame()


def render_search_page():
    st.title("🔍 Find Sponsors for Your Club")

    # Initialize service
    service = load_associations_service()

    # Search interface
    col1, col2 = st.columns([3, 1])

    with col1:
        search_query = st.text_input(
            "🏆 Search for your club...",
            placeholder="Type at least 2 characters",
            key="club_search"
        )

    with col2:
        max_distance = st.slider("Max distance (km):", 1, 100, 25)
        top_n = st.slider("Number of sponsors:", 5, 20, 10)

    # Initialize session state
    if 'selected_club' not in st.session_state:
        st.session_state.selected_club = None
    if 'sponsors' not in st.session_state:
        st.session_state.sponsors = []

    # Search for clubs
    if search_query and len(search_query) >= 2 and service:
        associations_df = search_associations(service, search_query)

        if not associations_df.empty:
            st.write("**Select your club:**")

            # Display search results
            for _, assoc in associations_df.iterrows():
                display_name = f"{assoc['name']}"
                if assoc.get('address'):
                    display_name += f" - {assoc['address']}"

                if st.button(display_name, key=f"club_{assoc['id']}", use_container_width=True):
                    # Get full association details
                    club_details = service.get_association_by_name(assoc['name'])
                    if club_details:
                        st.session_state.selected_club = club_details
                        st.rerun()
        else:
            st.info("No clubs found. Try different search terms.")

    # Show selected club and find sponsors
    if st.session_state.selected_club:
        club = st.session_state.selected_club

        st.success(f"✅ Selected: **{club['name']}** ({club.get('size_bucket', 'unknown')} size)")

        if st.button("🎯 Find Sponsors", type="primary", use_container_width=True):
            with st.spinner("Searching for matching sponsors..."):
                try:
                    # Use the ML pipeline for recommendations
                    sponsors = score_and_rank(
                        association_id=club['id'],
                        bucket=club.get('size_bucket', 'medium'),
                        max_distance=max_distance,
                        top_n=top_n
                    )

                    st.session_state.sponsors = sponsors

                    if sponsors:
                        st.success(f"Found {len(sponsors)} potential sponsors!")
                    else:
                        st.warning("No sponsors found in the specified area.")

                except Exception as e:
                    st.error(f"Error finding sponsors: {e}")
                    st.session_state.sponsors = []

    # Display map
    render_map(st.session_state.selected_club, st.session_state.sponsors)

    # Display sponsor results
    if st.session_state.sponsors:
        st.subheader("🏢 Recommended Sponsors")

        # Create tabs for different views
        tab1, tab2 = st.tabs(["List View", "Details"])

        with tab1:
            # Display sponsors in a clean list
            for i, sponsor in enumerate(st.session_state.sponsors, 1):
                with st.container():
                    col1, col2, col3, col4 = st.columns([3, 1, 1, 1])

                    with col1:
                        # Handle both name and id fallback
                        sponsor_name = sponsor.get('name', f"Company #{sponsor.get('id', i)}")
                        st.write(f"**{i}. {sponsor_name}**")
                    with col2:
                        st.metric("Distance", f"{sponsor['distance']:.1f} km")
                    with col3:
                        st.metric("Match", f"{sponsor['score'] * 100:.0f}%")
                    with col4:
                        if st.button("Contact", key=f"contact_{sponsor['id']}"):
                            st.info(f"Contact feature coming soon for {sponsor.get('name', 'Company')}")

                    st.divider()

        with tab2:
            # Detailed view with expandable sections
            for sponsor in st.session_state.sponsors:
                with st.expander(f"{sponsor['name']} - {sponsor['distance']:.1f}km"):
                    col1, col2 = st.columns(2)

                    with col1:
                        st.metric("Distance", f"{sponsor['distance']:.1f} km")
                        st.metric("Coordinates", f"{sponsor['lat']:.4f}, {sponsor['lon']:.4f}")

                    with col2:
                        st.metric("Match Score", f"{sponsor['score'] * 100:.0f}%")
                        st.button(
                            f"📧 Contact {sponsor['name']}",
                            key=f"detail_contact_{sponsor['id']}",
                            use_container_width=True
                        )


def render_map(selected_club, sponsors):
    """Render interactive map with club and sponsors."""

    # Default center on Gothenburg
    center_lat, center_lon = 57.7089, 11.9746
    zoom = 11

    # Center on selected club if available
    if selected_club and selected_club.get('lat') and selected_club.get('lon'):
        center_lat = float(selected_club['lat'])
        center_lon = float(selected_club['lon'])
        zoom = 12

    # Create map with colorful OpenStreetMap tiles
    m = folium.Map(
        location=[center_lat, center_lon],
        zoom_start=zoom,
        tiles='OpenStreetMap'  # More colorful than CartoDB
    )

    # Add club marker
    if selected_club and selected_club.get('lat') and selected_club.get('lon'):
        folium.Marker(
            location=[float(selected_club['lat']), float(selected_club['lon'])],
            popup=folium.Popup(
                f"<b>{selected_club['name']}</b><br>"
                f"Members: {selected_club.get('member_count', 'N/A')}<br>"
                f"{selected_club.get('address', '')}",
                max_width=300
            ),
            icon=folium.Icon(color='purple', icon='star', prefix='fa'),
            tooltip=selected_club['name']
        ).add_to(m)

        # Add a circle around the club to show search radius
        folium.Circle(
            location=[float(selected_club['lat']), float(selected_club['lon'])],
            radius=2000,  # 2km radius
            color='purple',
            fill=True,
            fillOpacity=0.1
        ).add_to(m)

    # Add sponsor markers
    if sponsors:
        for sponsor in sponsors:
            if sponsor.get('lat') and sponsor.get('lon'):
                # More vibrant colors based on match score
                if sponsor['score'] > 0.8:
                    color = 'darkgreen'
                    icon_color = 'white'
                elif sponsor['score'] > 0.7:
                    color = 'green'
                    icon_color = 'white'
                elif sponsor['score'] > 0.6:
                    color = 'lightgreen'
                    icon_color = 'black'
                elif sponsor['score'] > 0.5:
                    color = 'orange'
                    icon_color = 'white'
                elif sponsor['score'] > 0.4:
                    color = 'beige'
                    icon_color = 'black'
                else:
                    color = 'lightblue'
                    icon_color = 'black'

                # Add colored circle around high-match sponsors
                if sponsor['score'] > 0.7:
                    folium.Circle(
                        location=[float(sponsor['lat']), float(sponsor['lon'])],
                        radius=200,
                        color=color,
                        fill=True,
                        fillOpacity=0.3
                    ).add_to(m)

                folium.Marker(
                    location=[float(sponsor['lat']), float(sponsor['lon'])],
                    popup=folium.Popup(
                        f"<div style='width:200px'>"
                        f"<h4 style='color:black'>{sponsor['name']}</h4>"
                        f"<b>Distance:</b> {sponsor['distance']:.1f}km<br>"
                        f"<b>Match:</b> {sponsor['score'] * 100:.0f}%<br>"
                        f"<div style='background:{color};color:{icon_color};padding:5px;margin-top:5px;text-align:center;border-radius:5px'>"
                        f"{'Excellent Match!' if sponsor['score'] > 0.8 else 'Good Match' if sponsor['score'] > 0.6 else 'Potential Match'}"
                        f"</div>"
                        f"</div>",
                        max_width=250
                    ),
                    icon=folium.Icon(color=color, icon='briefcase' if sponsor['score'] > 0.7 else 'building',
                                     prefix='fa'),
                    tooltip=f"{sponsor['name']} ({sponsor['score'] * 100:.0f}% match)"
                ).add_to(m)

    # Display map
    st.subheader("📍 Interactive Map")

    # Try folium_static first (more reliable)
    try:
        folium_static(m, width=700, height=500)
    except:
        # Fallback to st_folium if static fails
        st_folium(m, height=500, width=None, returned_objects=["last_object_clicked"])


if __name__ == "__main__":
    render_search_page()


================================================================================
FIL: sponsor_match/core/config.py
================================================================================

import os
from pathlib import Path
from dotenv import load_dotenv
from urllib.parse import quote_plus

load_dotenv()

# Base directories
BASE_DIR = Path(__file__).parent.parent.resolve()
DATA_DIR = BASE_DIR / "data"
MODELS_DIR = BASE_DIR / "models"


# Database configuration - Fixed
def get_database_url():
    mysql_user = os.getenv("MYSQL_USER", "sponsor_user")
    mysql_password = os.getenv("MYSQL_PASSWORD", "Sports-2025?!")
    mysql_host = os.getenv("MYSQL_HOST", "localhost")
    mysql_port = os.getenv("MYSQL_PORT", "3306")
    mysql_db = os.getenv("MYSQL_DB", "sponsor_registry")

    # URL encode password to handle special characters
    encoded_password = quote_plus(mysql_password)

    return f"mysql+pymysql://{mysql_user}:{encoded_password}@{mysql_host}:{mysql_port}/{mysql_db}"


DATABASE_URL = get_database_url()

# App constants
APP_TITLE = os.getenv("APP_TITLE", "SponsorMatch AI")
LOGO_PATH = os.getenv("LOGO_PATH", str(BASE_DIR / "assets" / "logo.png"))
STREAMLIT_PAGE_ICON = "⚽"

# Other settings
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
N_CLUSTERS = int(os.getenv("N_CLUSTERS", 5))
RANDOM_STATE = int(os.getenv("CLUSTER_RANDOM_STATE", 42))

================================================================================
FIL: sponsor_match/core/db.py
================================================================================

import logging

from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.exc import SQLAlchemyError

load_dotenv()
_engine = None


def get_engine():
    global _engine
    if _engine is None:
        # Get URL from config
        from sponsor_match.core.config import DATABASE_URL

        if not DATABASE_URL:
            raise RuntimeError("DATABASE_URL not configured")

        try:
            _engine = create_engine(
                DATABASE_URL,
                pool_size=5,
                max_overflow=10,
                pool_recycle=3600,
                pool_pre_ping=True,  # Test connections before use
                echo=False,
            )
            logging.info("Database engine created successfully")
        except SQLAlchemyError as e:
            logging.error(f"Failed to create database engine: {e}")
            raise
    return _engine


================================================================================
FIL: sponsor_match/core/logger.py
================================================================================

#!/usr/bin/env python3
"""
sponsor_match/core/logger.py
----------------------------
Utility to configure and retrieve named loggers, with console
and optional file handlers.
"""

import logging
import sys
from pathlib import Path

def setup_logger(
    name: str,
    log_file: Path | None = None,
    level: int = logging.INFO
) -> logging.Logger:
    """
    Return a logger configured with:
      - StreamHandler (stdout) at `level`
      - Optional FileHandler if `log_file` is provided
    """
    logger = logging.getLogger(name)
    if logger.handlers:
        # Already configured
        return logger

    logger.setLevel(level)
    fmt = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    formatter = logging.Formatter(fmt)

    console = logging.StreamHandler(sys.stdout)
    console.setLevel(level)
    console.setFormatter(formatter)
    logger.addHandler(console)

    if log_file:
        file_h = logging.FileHandler(log_file)
        file_h.setLevel(level)
        file_h.setFormatter(formatter)
        logger.addHandler(file_h)

    return logger


================================================================================
FIL: sponsor_match/ml/pipeline.py
================================================================================

import math
from pathlib import Path

import joblib
import pandas as pd
from sqlalchemy import text

from sponsor_match.core.db import get_engine

MODELS_DIR = Path(__file__).resolve().parents[2] / "models"
DEFAULT_KMEANS = MODELS_DIR / "kmeans.joblib"
LARGE_KMEANS = MODELS_DIR / "kmeans_large.joblib"


def haversine(lat1, lon1, lat2, lon2):
    """Compute great-circle distance (km) between two points."""
    R = 6371.0
    phi1, lam1, phi2, lam2 = map(math.radians, (lat1, lon1, lat2, lon2))
    dphi = phi2 - phi1
    dlam = lam2 - lam1
    a = (math.sin(dphi / 2) ** 2 +
         math.cos(phi1) * math.cos(phi2) * math.sin(dlam / 2) ** 2)
    return 2 * R * math.asin(math.sqrt(a))


def size_bucket_to_numeric(size_bucket):
    """Convert size bucket to numeric value."""
    mapping = {"small": 0, "medium": 1, "large": 2}
    return mapping.get(size_bucket, 1)


def load_models():
    """Load clustering models with error handling."""
    try:
        models = {}
        if DEFAULT_KMEANS.exists():
            models["default"] = joblib.load(DEFAULT_KMEANS)
        if LARGE_KMEANS.exists():
            models["large"] = joblib.load(LARGE_KMEANS)
        return models if models else None
    except Exception as e:
        print(f"Warning: Could not load models: {e}")
        return None


def safe_predict_cluster(model_data, features):
    """Safely predict cluster with new model format."""
    try:
        # Handle new model format (dict with scaler and kmeans)
        if isinstance(model_data, dict):
            scaler = model_data.get('scaler')
            kmeans = model_data.get('kmeans')

            if scaler and kmeans:
                # Scale features
                features_scaled = scaler.transform([features[:2]])  # Use only lat/lon
                # Predict cluster
                return kmeans.predict(features_scaled)[0]

        # Handle old model format (direct kmeans object)
        elif hasattr(model_data, 'predict'):
            # Check expected features
            expected_features = getattr(model_data, 'n_features_in_', None)
            if expected_features is None and hasattr(model_data, 'cluster_centers_'):
                expected_features = model_data.cluster_centers_.shape[1]

            if expected_features and len(features) != expected_features:
                print(f"Feature mismatch: model expects {expected_features}, got {len(features)}")
                # Pad or truncate features to match
                if len(features) < expected_features:
                    features = features + [0] * (expected_features - len(features))
                else:
                    features = features[:expected_features]

            return model_data.predict([features])[0]

    except Exception as e:
        print(f"Clustering prediction failed: {e}")
        return None


def score_and_rank(association_id, bucket, max_distance=50.0, top_n=10):
    """Score and rank potential sponsors with robust error handling."""
    engine = get_engine()

    try:
        with engine.connect() as conn:
            # Get association
            assoc_df = pd.read_sql(
                text("SELECT id,name,lat,lon,size_bucket,member_count FROM associations WHERE id=:i"),
                conn, params={"i": association_id}
            )

            # Get companies with all needed fields
            comps_df = pd.read_sql(
                "SELECT id,name,lat,lon,size_bucket,revenue_ksek,employees,industry FROM companies WHERE lat IS NOT NULL AND lon IS NOT NULL",
                conn
            )
    except Exception as e:
        print(f"Database error: {e}")
        return []

    if assoc_df.empty:
        return []

    club = assoc_df.iloc[0]

    # Load models
    models = load_models()
    club_cluster = None

    if models:
        model_key = "large" if bucket == "large" else "default"
        model = models.get(model_key)

        if model:
            # Prepare features (lat, lon)
            club_features = [club.lat, club.lon]
            club_cluster = safe_predict_cluster(model, club_features)

    recommendations = []
    for _, company in comps_df.iterrows():
        try:
            distance = haversine(club.lat, club.lon, company.lat, company.lon)
            if distance > max_distance:
                continue

            # Size matching bonus
            size_bonus = 1.2 if company.size_bucket == bucket else 1.0

            # Cluster matching bonus (if clustering worked)
            comp_cluster_bonus = 1.0
            if models and club_cluster is not None:
                model_key = "large" if company.size_bucket == "large" else "default"
                model = models.get(model_key)
                if model:
                    comp_features = [company.lat, company.lon]
                    comp_cluster = safe_predict_cluster(model, comp_features)
                    if comp_cluster is not None and comp_cluster == club_cluster:
                        comp_cluster_bonus = 1.3

            # Calculate final score
            score = (1.0 / (1.0 + distance)) * size_bonus * comp_cluster_bonus

            recommendations.append({
                "id": int(company.id),
                "name": str(company['name']),  # Fix: use column access instead of attribute
                "lat": float(company.lat),
                "lon": float(company.lon),
                "distance": round(distance, 2),
                "score": round(score, 3)
            })

        except Exception as e:
            print(f"Error processing company {company.get('name', 'unknown')}: {e}")
            continue

    # Sort by score and return top N
    recommendations.sort(key=lambda x: x["score"], reverse=True)
    return recommendations[:top_n]


