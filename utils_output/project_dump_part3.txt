================================================================================
FIL: sponsor_match/ui/styles.py
================================================================================

import streamlit as st


def apply_professional_styles():
    """Apply professional styling to Streamlit app."""
    css = """
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    /* Main app styling */
    .main .block-container {
        font-family: 'Inter', sans-serif;
        padding-top: 1rem;
        padding-bottom: 2rem;
        max-width: 1200px;
    }

    /* Header styling */
    h1 {
        color: #1e40af !important;
        font-weight: 700 !important;
        margin-bottom: 2rem !important;
    }

    h2 {
        color: #1e40af !important;
        font-weight: 600 !important;
        margin-bottom: 1.5rem !important;
    }

    /* Button styling */
    .stButton > button {
        background-color: #2563eb;
        color: white;
        border-radius: 8px;
        font-weight: 500;
        border: none;
        padding: 0.5rem 1rem;
        transition: all 0.2s ease;
    }

    .stButton > button:hover {
        background-color: #1d4ed8;
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
        transform: translateY(-1px);
    }

    /* Metric cards */
    [data-testid="metric-container"] {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    /* Sidebar styling */
    .css-1d391kg {
        background-color: #f8fafc;
    }

    /* Input fields */
    .stTextInput > div > div > input {
        border-radius: 6px;
        border: 1px solid #d1d5db;
    }

    .stTextInput > div > div > input:focus {
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    /* Success/Error styling */
    .stSuccess {
        background-color: #f0f9ff;
        border-left: 4px solid #10b981;
    }

    .stError {
        background-color: #fef2f2;
        border-left: 4px solid #ef4444;
    }
    </style>
    """
    st.markdown(css, unsafe_allow_html=True)


def create_metric_card(title, value, delta=None):
    """Create a styled metric card."""
    delta_html = ""
    if delta:
        color = "#10b981" if delta > 0 else "#ef4444"
        arrow = "‚Üó" if delta > 0 else "‚Üò"
        delta_html = f"""
        <div style="color: {color}; font-size: 0.875rem; font-weight: 500;">
            {arrow} {abs(delta):.1f}%
        </div>
        """

    return f"""
    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 8px; 
                padding: 1.5rem; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);">
        <div style="color: #6b7280; font-size: 0.875rem; margin-bottom: 0.5rem;">
            {title}
        </div>
        <div style="font-size: 1.875rem; font-weight: 700; color: #111827; margin-bottom: 0.25rem;">
            {value}
        </div>
        {delta_html}
    </div>
    """

================================================================================
FIL: sponsor_match/ui/services/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/services/data_service.py
================================================================================

"""
Data service for handling data loading and initialization.
"""
import logging

import pandas as pd

from sponsor_match.core.db import get_engine
from sponsor_match.ui.utils.sessions import set_session_data

logger = logging.getLogger(__name__)

# Global caches
_engine = None
_clubs_df = None
_companies_df = None


def load_initial_data():
    """
    Load initial data needed by the application.
    This should be called once at startup.
    """
    try:
        # Initialize engine
        global _engine
        _engine = get_engine()
        logger.info("Database engine initialized")

        # Load clubs
        load_clubs()

        # Load only if needed in UI
        # load_companies()

        return True
    except Exception as e:
        logger.error(f"Error loading initial data: {e}")
        return False


def load_clubs():
    """
    Load clubs from database or use fallback data.

    Returns:
        DataFrame of clubs
    """
    global _clubs_df

    # Return cached data if available
    if _clubs_df is not None:
        return _clubs_df

    try:
        if _engine:
            _clubs_df = pd.read_sql("SELECT * FROM clubs", _engine)
            logger.info(f"Loaded {len(_clubs_df)} clubs from database")
            return _clubs_df
    except Exception as e:
        logger.warning(f"Failed to load clubs from database: {e}")

    # Create sample data as fallback
    _clubs_df = pd.DataFrame({
        'id': [1, 2, 3],
        'name': ['IFK G√∂teborg', 'GAIS', 'BK H√§cken'],
        'size_bucket': ['large', 'medium', 'medium'],
        'member_count': [500, 250, 300],
        'lat': [57.7089, 57.6969, 57.7209],
        'lon': [11.9746, 11.9789, 11.9390],
        'address': ['G√∂teborg', 'G√∂teborg', 'G√∂teborg']
    })
    logger.info("Using sample club data")

    return _clubs_df


def load_companies():
    """
    Load companies from database or use fallback data.

    Returns:
        DataFrame of companies
    """
    global _companies_df

    # Return cached data if available
    if _companies_df is not None:
        return _companies_df

    try:
        if _engine:
            _companies_df = pd.read_sql("SELECT * FROM companies", _engine)
            logger.info(f"Loaded {len(_companies_df)} companies from database")
            return _companies_df
    except Exception as e:
        logger.warning(f"Failed to load companies from database: {e}")

    # Create sample data as fallback
    _companies_df = pd.DataFrame([
        {
            "id": 1,
            "name": "Nordic Bank",
            "revenue_ksek": 50000,
            "employees": 120,
            "industry": "Finance",
            "size_bucket": "large",
            "lat": 57.70,
            "lon": 11.97
        },
        {
            "id": 2,
            "name": "Energigruppen AB",
            "revenue_ksek": 25000,
            "employees": 45,
            "industry": "Energy",
            "size_bucket": "medium",
            "lat": 57.71,
            "lon": 11.98
        }
    ])
    logger.info("Using sample company data")

    return _companies_df


def get_club_by_id(club_id):
    """
    Get a club by its ID.

    Args:
        club_id: Club ID to look up

    Returns:
        Club dictionary or None if not found
    """
    # Load clubs if needed
    clubs = load_clubs()

    # Find club by ID
    club_row = clubs[clubs['id'] == club_id]
    if len(club_row) > 0:
        return club_row.iloc[0].to_dict()

    return None


def save_club(club_data):
    """
    Save club data to database.
    This is a placeholder - in a real app, this would update the database.

    Args:
        club_data: Dictionary of club data to save

    Returns:
        True if successful, False otherwise
    """
    # In a real application, this would save to the database
    logger.info(f"Saving club data: {club_data}")

    # For now, just store in session state
    set_session_data("selected_club", club_data)

    # Pretend it was successful
    return True


================================================================================
FIL: sponsor_match/ui/services/search_services.py
================================================================================

from sponsor_match.ml.pipeline import score_and_rank

def recommend_sponsors(club_id: int, club_bucket: str,
                       max_distance: float = 50.0, top_n: int = 10):
    """
    Returns list of {id,name,lat,lon,distance,score} for top_n companies.
    """
    return score_and_rank(
        assoc_id=club_id,
        assoc_bucket=club_bucket,
        max_distance=max_distance,
        top_n=top_n
    )


================================================================================
FIL: sponsor_match/ui/components/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/components/cards.py
================================================================================

"""
Card UI components for SponsorMatch application.
"""
import streamlit as st


def render_info_card(icon, title, text):
    """
    Render an information card with icon, title and text.

    Args:
        icon: Emoji or icon character
        title: Card title
        text: Card description text
    """
    st.markdown(
        f"""
        <div style="background:#eff6ff;border:1px solid #bfdbfe;border-radius:8px;
                    padding:1.5rem;text-align:center;box-shadow:0 1px 2px rgba(0,0,0,0.05);">
          <div style="font-size:2rem;color:#2563eb;margin-bottom:0.5rem;">{icon}</div>
          <div style="font-size:1.125rem;font-weight:600;color:#1e40af;margin-bottom:0.5rem;">{title}</div>
          <div style="font-size:0.875rem;color:#4b5563;">{text}</div>
        </div>
        """,
        unsafe_allow_html=True,
    )


def render_sponsor_card(sponsor):
    """
    Render a sponsor card with company information and contact button.

    Args:
        sponsor: Dictionary containing sponsor information
    """
    # Extract sponsor details, with defaults for missing values
    name = sponsor.get('name', 'Unknown Sponsor')
    description = sponsor.get('description', 'No description available.')
    score = sponsor.get('score', 0)
    revenue = sponsor.get('revenue_ksek', 'N/A')
    employees = sponsor.get('employees', 'N/A')
    industry = sponsor.get('industry', 'N/A')

    # Format score as percentage
    score_display = f"{score:.0%}" if isinstance(score, (int, float)) else "N/A"

    # Create formatted card with all information
    st.markdown(
        f"""
        <div style="background:white;padding:1.5rem;border-radius:8px;
                    box-shadow:0 1px 3px rgba(0,0,0,0.1);margin-bottom:1rem;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
            <div style="font-size:1.125rem;font-weight:700;color:#1e40af;">{name}</div>
            <div style="background:#dbeafe;color:#1e40af;padding:0.25rem 0.5rem;
                        border-radius:9999px;font-size:0.75rem;font-weight:600;">
              {score_display} match
            </div>
          </div>
          <div style="font-size:0.875rem;color:#4b5563;margin-bottom:0.75rem;">{description}</div>
          <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:0.5rem;
                      font-size:0.75rem;color:#6b7280;margin-bottom:1rem;">
            <div>
              <div style="font-weight:600;">Oms√§ttning</div>
              <div>{revenue} tkr</div>
            </div>
            <div>
              <div style="font-weight:600;">Anst√§llda</div>
              <div>{employees}</div>
            </div>
            <div>
              <div style="font-weight:600;">Bransch</div>
              <div>{industry}</div>
            </div>
          </div>
          <div style="display:flex;gap:0.5rem;">
            <button style="flex:1;background:#2563eb;color:white;padding:0.5rem 1rem;
                           border:none;border-radius:4px;font-weight:500;cursor:pointer;">
              üìß Kontakta
            </button>
            <button style="flex:1;background:#f3f4f6;color:#374151;padding:0.5rem 1rem;
                           border:none;border-radius:4px;font-weight:500;cursor:pointer;">
              ‚ÑπÔ∏è Detaljer
            </button>
          </div>
        </div>
        """,
        unsafe_allow_html=True,
    )


def render_stat_card(title, value, description=None, trend=None):
    """
    Render a statistic card with optional trend indicator.

    Args:
        title: Stat title
        value: Main value to display
        description: Optional description or context
        trend: Optional trend value (positive or negative number)
    """
    # Determine trend styling
    trend_html = ""
    if trend is not None:
        trend_color = "#10b981" if trend > 0 else "#ef4444"  # Green or red
        trend_arrow = "‚Üë" if trend > 0 else "‚Üì"
        trend_html = f"""
        <div style="color:{trend_color};font-size:0.875rem;font-weight:600;">
          {trend_arrow} {abs(trend):.1f}%
        </div>
        """

    # Description HTML if provided
    desc_html = f"""
    <div style="color:#6b7280;font-size:0.75rem;">
      {description}
    </div>
    """ if description else ""

    # Render the card
    st.markdown(
        f"""
        <div style="background:white;padding:1.25rem;border-radius:8px;
                    box-shadow:0 1px 3px rgba(0,0,0,0.1);height:100%;">
          <div style="color:#6b7280;font-size:0.875rem;margin-bottom:0.5rem;">
            {title}
          </div>
          <div style="display:flex;align-items:baseline;gap:0.5rem;">
            <div style="font-size:1.5rem;font-weight:700;color:#111827;">
              {value}
            </div>
            {trend_html}
          </div>
          {desc_html}
        </div>
        """,
        unsafe_allow_html=True,
    )


================================================================================
FIL: sponsor_match/ui/components/map_view.py
================================================================================

# sponsor_match/ui/components/map_view.py

import streamlit as st
from folium import Map, Marker, Popup, Icon
from folium.plugins import MarkerCluster, HeatMap
from streamlit_folium import st_folium

def render_map(club=None, sponsors=None, height=400, width=None):
    """
    Render an interactive map with club and sponsor markers.

    Args:
        club: Dictionary with club information (optional)
        sponsors: List of sponsor dictionaries (optional)
        height: Map height in pixels (default 400)
        width:  Map width in pixels (optional; omit to auto-size)
    """
    # Default center on Gothenburg
    center = [57.7089, 11.9746]
    if club and club.get('lat') and club.get('lon'):
        center = [club['lat'], club['lon']]

    m = Map(location=center, zoom_start=12, tiles="CartoDB positron")

    # Club marker
    if club and club.get('lat') and club.get('lon'):
        Marker(
            location=[club['lat'], club['lon']],
            popup=Popup(_club_popup(club), max_width=300),
            icon=Icon(color='purple', icon='flag', prefix='fa'),
            tooltip=club.get('name', 'Club')
        ).add_to(m)

    # Sponsor markers
    if sponsors:
        cluster = MarkerCluster().add_to(m)
        heat_data = []
        for sponsor in sponsors:
            if sponsor.get('lat') and sponsor.get('lon'):
                Marker(
                    location=[sponsor['lat'], sponsor['lon']],
                    popup=Popup(_sponsor_popup(sponsor), max_width=300),
                    icon=Icon(color=_marker_color(sponsor), icon='building', prefix='fa'),
                    tooltip=sponsor.get('name', 'Sponsor')
                ).add_to(cluster)
                if sponsor.get('score') is not None:
                    heat_data.append([sponsor['lat'], sponsor['lon'], sponsor['score']])
        if heat_data:
            HeatMap(heat_data).add_to(m)

    # Only pass width if it‚Äôs a real integer
    if width:
        return st_folium(m, width=width, height=height)
    else:
        return st_folium(m, height=height)


def _club_popup(club):
    return f"""
    <div style="width:200px">
        <h4>{club.get('name','')}</h4>
        <p><b>Medlemmar:</b> {club.get('member_count','N/A')}</p>
        <p><b>Storlek:</b> {club.get('size_bucket','').title()}</p>
        <p><b>Adress:</b> {club.get('address','N/A')}</p>
    </div>
    """

def _sponsor_popup(sponsor):
    contact = sponsor.get('contact', {})
    return f"""
    <div style="width:200px">
        <h4>{sponsor.get('name','')}</h4>
        <p>{sponsor.get('description','')}</p>
        <p>üìß {contact.get('email','')}</p>
        <p>üìû {contact.get('phone','')}</p>
    </div>
    """

def _marker_color(sponsor):
    score = sponsor.get('score', 0)
    if score >= 75:
        return 'green'
    if score >= 50:
        return 'orange'
    return 'red'


================================================================================
FIL: sponsor_match/ui/components/modals.py
================================================================================

"""
Modal dialog components for SponsorMatch application.
"""
import streamlit as st


def show_login_modal():
    """Show a login modal dialog."""
    # Use Streamlit's experimental modal feature if available
    use_experimental = hasattr(st, "modal")

    if use_experimental:
        with st.modal("Logga in", key="login_modal"):
            _render_login_form()
    else:
        # Fallback to expander
        with st.expander("Logga in", expanded=True):
            _render_login_form()


def show_sponsor_modal(sponsor):
    """
    Show a sponsor details modal dialog.

    Args:
        sponsor: Dictionary with sponsor information
    """
    use_experimental = hasattr(st, "modal")
    title = sponsor.get('name', 'Sponsor')

    if use_experimental:
        with st.modal(title, key="sponsor_modal"):
            _render_sponsor_details(sponsor)
    else:
        # Fallback to expander
        with st.expander(title, expanded=True):
            _render_sponsor_details(sponsor)


def show_confirmation_modal(title, message, confirm_text="Bekr√§fta", cancel_text="Avbryt"):
    """
    Show a confirmation dialog and return the result.

    Args:
        title: Modal title
        message: Message to display
        confirm_text: Text for confirm button
        cancel_text: Text for cancel button

    Returns:
        True if confirmed, False otherwise
    """
    use_experimental = hasattr(st, "modal")

    if use_experimental:
        with st.modal(title, key="confirm_modal"):
            st.write(message)
            col1, col2 = st.columns(2)
            with col1:
                if st.button(cancel_text, key="modal_cancel"):
                    return False
            with col2:
                if st.button(confirm_text, key="modal_confirm", type="primary"):
                    return True
    else:
        # Fallback to regular UI
        st.write(message)
        col1, col2 = st.columns(2)
        with col1:
            if st.button(cancel_text, key="confirm_cancel"):
                return False
        with col2:
            if st.button(confirm_text, key="confirm_confirm", type="primary"):
                return True

    return False


def _render_login_form():
    """Render login form content."""
    st.text_input("E-post", key="login_email")
    st.text_input("L√∂senord", type="password", key="login_password")

    col1, col2 = st.columns(2)
    with col1:
        st.checkbox("Kom ih√•g mig", key="remember_me")
    with col2:
        st.markdown(
            "<div style='text-align:right;'><a href='#'>Gl√∂mt l√∂senord?</a></div>",
            unsafe_allow_html=True
        )

    if st.button("Logga in", type="primary", key="do_login"):
        st.success("Inloggning lyckades!")
        return True

    st.markdown("---")
    st.markdown("Har du inget konto? [Registrera dig h√§r](#)")

    return False


def _render_sponsor_details(sponsor):
    """Render sponsor details content."""
    # Extract sponsor details with defaults
    name = sponsor.get('name', 'Unknown Sponsor')
    description = sponsor.get('description', 'No description available.')
    industry = sponsor.get('industry', 'N/A')
    revenue = sponsor.get('revenue_ksek', 'N/A')
    employees = sponsor.get('employees', 'N/A')
    website = sponsor.get('website', '#')
    email = sponsor.get('contact', {}).get('email', 'kontakt@f√∂retag.se')
    phone = sponsor.get('contact', {}).get('phone', 'N/A')

    # Display sponsor information
    st.subheader(name)
    st.write(description)

    # Company details
    st.markdown("### F√∂retagsinformation")
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Bransch", industry)
    with col2:
        st.metric("Oms√§ttning", f"{revenue} tkr")
    with col3:
        st.metric("Anst√§llda", employees)

    # Contact information
    st.markdown("### Kontaktuppgifter")
    st.write(f"üìß E-post: {email}")
    st.write(f"üìû Telefon: {phone}")
    if website != '#':
        st.write(f"üåê [Bes√∂k webbplats]({website})")

    # Contact form
    st.markdown("### Skicka meddelande")
    with st.form("contact_form"):
        st.text_area("Meddelande", placeholder="Skriv ditt meddelande h√§r...")
        submitted = st.form_submit_button("Skicka")

        if submitted:
            st.success("Meddelande skickat!")


================================================================================
FIL: sponsor_match/ui/components/sidebar.py
================================================================================

"""
Sidebar component for SponsorMatch application.
"""
import streamlit as st
from sponsor_match.ui.utils.session import clear_session_data


def render_sidebar():
    """Render the application sidebar."""
    with st.sidebar:
        st.title("üèÜ SponsorMatch AI")
        st.markdown("Hitta r√§tt sponsorer f√∂r din idrottsf√∂rening")
        st.divider()

        # Settings section
        st.subheader("Inst√§llningar")
        api_key = st.text_input("API-nyckel", value="demo-key", type="password")
        st.checkbox("Avancerad matchning", value=True,
                    help="Aktivera AI-baserad matchning")

        # Language selection
        st.selectbox("Spr√•k", ["Svenska", "English"], index=0)

        st.divider()

        # User actions
        if st.button("Rensa s√∂khistorik"):
            clear_session_data("search_results")
            clear_session_data("search_scores")
            st.success("S√∂khistorik rensad!")

        if st.button("Logga ut"):
            clear_session_data()
            st.success("Du har loggats ut.")

        # About section
        st.markdown("### Om SponsorMatch AI")
        st.markdown("""
        SponsorMatch AI hj√§lper idrottsf√∂reningar att hitta och kontakta l√§mpliga 
        f√∂retag som kan bli sponsorer.

        Vi anv√§nder AI f√∂r att matcha f√∂reningar med f√∂retag baserat p√• geografi, 
        storlek, bransch och v√§rderingar.
        """)

        st.markdown("Made with ‚ù§Ô∏è by Team 14")

        # Version info
        st.caption("Version 1.0.0")


================================================================================
FIL: sponsor_match/ui/utils/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/utils/sessions.py
================================================================================

"""
Utilities for managing Streamlit session state.
"""
import streamlit as st


def get_session_data(key, default=None):
    """
    Get data from session state with fallback to default.

    Args:
        key: Session state key
        default: Default value if key doesn't exist

    Returns:
        Value from session state or default
    """
    return st.session_state.get(key, default)


def set_session_data(key, value):
    """
    Set data in session state.

    Args:
        key: Session state key
        value: Value to store
    """
    st.session_state[key] = value


def clear_session_data(key=None):
    """
    Clear data from session state.

    Args:
        key: Specific key to clear, or None to clear all app-specific keys
    """
    if key is not None and key in st.session_state:
        del st.session_state[key]
    elif key is None:
        # Clear all app-specific keys (doesn't affect Streamlit's internal keys)
        app_keys = [k for k in st.session_state.keys()
                    if not k.startswith('_') and k not in ['formSubmitter', 'formKey']]
        for k in app_keys:
            del st.session_state[k]


================================================================================
FIL: sponsor_match/ui/pages/__init__.py
================================================================================



================================================================================
FIL: sponsor_match/ui/pages/home.py
================================================================================

#!/usr/bin/env python3
"""
sponsor_match/ui/pages/home.py

Home page for SponsorMatch application.
"""

import streamlit as st

def render_home_page():
    """Render the home page with responsive cards."""
    st.markdown(
        "<h2 style='font-size:2rem;font-weight:600;color:var(--primaryColor);'>"
        "V√§lkommen till SponsorMatch</h2>",
        unsafe_allow_html=True,
    )

    # open the flex container
    st.markdown('<div class="card-container">', unsafe_allow_html=True)

    # each card
    cards = [
        ("‚ú®", "Tips & tricks", "R√•d f√∂r att locka sponsorer snabbare."),
        ("‚öôÔ∏è", "Inst√§llningar",       "Justera profil, sekretess och synlighet."),
        ("‚ÑπÔ∏è", "Om SponsorMatch",     "S√• fungerar plattformen och aff√§rsmodellen."),
    ]
    for icon, title, desc in cards:
        st.markdown(
            f"""
            <div class="card">
              <div style="font-size:2rem;color:var(--primaryColor);">{icon}</div>
              <h3 style="margin:0.5rem 0;color:var(--primaryColor);">{title}</h3>
              <p style="margin:0;color:var(--textColor);">{desc}</p>
            </div>
            """,
            unsafe_allow_html=True,
        )

    # close the flex container
    st.markdown('</div>', unsafe_allow_html=True)


================================================================================
FIL: sponsor_match/ui/pages/profile.py
================================================================================

#!/usr/bin/env python3
"""
sponsor_match/ui/pages/profile.py

Streamlit page for managing club profile.
"""

import streamlit as st

# fix: it's session.py, not sessions.py
from sponsor_match.ui.utils.sessions import get_session_data, set_session_data


def render_profile_page():
    st.markdown(
        "<h2 style='font-size:2rem;font-weight:600;color:var(--primaryColor);'>"
        "Min f√∂rening</h2>",
        unsafe_allow_html=True,
    )

    # get_session_data() may return None, so we coalesce to a dict
    club = get_session_data("selected_club") or {}

    if club:
        _render_profile_form(club)
    else:
        st.info(
            "Du har inte valt n√•gon f√∂rening. "
            "Anv√§nd s√∂kfunktionen f√∂r att hitta din f√∂rening."
        )
        _render_profile_form(None)

    with st.expander("Sponsorhistorik", expanded=False):
        _render_sponsorship_history()

    with st.expander("Inst√§llningar", expanded=False):
        _render_preferences()


def _render_profile_form(club: dict | None = None):
    with st.form("profile_form"):
        # prefill from club dict or fall back to empty strings
        name    = st.text_input("F√∂reningens namn", value=club.get("name","") if club else "")
        address = st.text_input("Adress",           value=club.get("address","") if club else "")

        # size bucket select
        size_labels = ["Liten", "Medel", "Stor"]
        rev_map     = {"Liten":"small","Medel":"medium","Stor":"large"}
        # figure out which index to preselect
        if club and club.get("size_bucket") in {"small","medium","large"}:
            pre = {"small":"Liten","medium":"Medel","large":"Stor"}[club["size_bucket"]]
            default_idx = size_labels.index(pre)
        else:
            default_idx = 1  # Medel
        size_sel = st.selectbox("Storlek", size_labels, index=default_idx)

        email = st.text_input("E-post",   value=club.get("email","") if club else "")
        phone = st.text_input("Telefon",  value=club.get("phone","") if club else "")
        desc  = st.text_area("Beskrivning", value=club.get("description","") if club else "")

        if st.form_submit_button("Spara profil"):
            st.success("Profilen har sparats!")
            profile = {
                "name":         name,
                "address":      address,
                "size_bucket":  rev_map[size_sel],
                "email":        email,
                "phone":        phone,
                "description":  desc,
            }
            # preserve id + coords if they existed
            if club:
                for key in ("id","latitude","longitude"):
                    if key in club:
                        profile[key] = club[key]
            set_session_data("selected_club", profile)


def _render_sponsorship_history():
    st.markdown("#### Nuvarande sponsorer")
    history = st.session_state.get("sponsors_history", [])
    if history:
        for s in history:
            st.write(f"**{s['name']}** ({s['contract_date']} ‚Äì {s['end_date']}) ‚Ä¢ {s['status']}")
            st.write("---")
    else:
        st.write("Inga aktiva sponsoravtal.")


def _render_preferences():
    st.markdown("#### Notifikationsinst√§llningar")
    st.checkbox("E-postaviseringar",   value=True,  key="email_notifications")
    st.checkbox("SMS-aviseringar",      value=False, key="sms_notifications")

    st.markdown("#### Sekretess")
    st.checkbox("Visa f√∂rening publikt",      value=True,  key="public_profile")
    st.checkbox("Till√•t kontakt fr√•n f√∂retag", value=True,  key="allow_contact")

    if st.button("Spara inst√§llningar", key="save_prefs"):
        st.success("Inst√§llningarna har sparats!")


================================================================================
FIL: sponsor_match/ui/pages/search.py
================================================================================

import streamlit as st
import pandas as pd
import folium
from streamlit_folium import st_folium, folium_static, folium_static

from sponsor_match.core.db import get_engine
from sponsor_match.services.service import SponsorMatchService
from sponsor_match.ml.pipeline import score_and_rank


def load_associations_service() -> SponsorMatchService:
    """Get the service instance."""
    try:
        engine = get_engine()
        return SponsorMatchService(engine)
    except Exception as e:
        st.error(f"Database connection error: {e}")
        return None


def search_associations(service: SponsorMatchService, query: str) -> pd.DataFrame:
    """Search for associations using the service."""
    if not service:
        return pd.DataFrame()

    try:
        # Use the service search method
        results = service.search(query)
        # Filter to only associations
        return results[results['type'] == 'association'].copy()
    except Exception as e:
        st.error(f"Search error: {e}")
        return pd.DataFrame()


def render_search_page():
    st.title("üîç Find Sponsors for Your Club")

    # Initialize service
    service = load_associations_service()

    # Search interface
    col1, col2 = st.columns([3, 1])

    with col1:
        search_query = st.text_input(
            "üèÜ Search for your club...",
            placeholder="Type at least 2 characters",
            key="club_search"
        )

    with col2:
        max_distance = st.slider("Max distance (km):", 1, 100, 25)
        top_n = st.slider("Number of sponsors:", 5, 20, 10)

    # Initialize session state
    if 'selected_club' not in st.session_state:
        st.session_state.selected_club = None
    if 'sponsors' not in st.session_state:
        st.session_state.sponsors = []

    # Search for clubs
    if search_query and len(search_query) >= 2 and service:
        associations_df = search_associations(service, search_query)

        if not associations_df.empty:
            st.write("**Select your club:**")

            # Display search results
            for _, assoc in associations_df.iterrows():
                display_name = f"{assoc['name']}"
                if assoc.get('address'):
                    display_name += f" - {assoc['address']}"

                if st.button(display_name, key=f"club_{assoc['id']}", use_container_width=True):
                    # Get full association details
                    club_details = service.get_association_by_name(assoc['name'])
                    if club_details:
                        st.session_state.selected_club = club_details
                        st.rerun()
        else:
            st.info("No clubs found. Try different search terms.")

    # Show selected club and find sponsors
    if st.session_state.selected_club:
        club = st.session_state.selected_club

        st.success(f"‚úÖ Selected: **{club['name']}** ({club.get('size_bucket', 'unknown')} size)")

        if st.button("üéØ Find Sponsors", type="primary", use_container_width=True):
            with st.spinner("Searching for matching sponsors..."):
                try:
                    # Use the ML pipeline for recommendations
                    sponsors = score_and_rank(
                        association_id=club['id'],
                        bucket=club.get('size_bucket', 'medium'),
                        max_distance=max_distance,
                        top_n=top_n
                    )

                    st.session_state.sponsors = sponsors

                    if sponsors:
                        st.success(f"Found {len(sponsors)} potential sponsors!")
                    else:
                        st.warning("No sponsors found in the specified area.")

                except Exception as e:
                    st.error(f"Error finding sponsors: {e}")
                    st.session_state.sponsors = []

    # Display map
    render_map(st.session_state.selected_club, st.session_state.sponsors)

    # Display sponsor results
    if st.session_state.sponsors:
        st.subheader("üè¢ Recommended Sponsors")

        # Create tabs for different views
        tab1, tab2 = st.tabs(["List View", "Details"])

        with tab1:
            # Display sponsors in a clean list
            for i, sponsor in enumerate(st.session_state.sponsors, 1):
                with st.container():
                    col1, col2, col3, col4 = st.columns([3, 1, 1, 1])

                    with col1:
                        # Handle both name and id fallback
                        sponsor_name = sponsor.get('name', f"Company #{sponsor.get('id', i)}")
                        st.write(f"**{i}. {sponsor_name}**")
                    with col2:
                        st.metric("Distance", f"{sponsor['distance']:.1f} km")
                    with col3:
                        st.metric("Match", f"{sponsor['score'] * 100:.0f}%")
                    with col4:
                        if st.button("Contact", key=f"contact_{sponsor['id']}"):
                            st.info(f"Contact feature coming soon for {sponsor.get('name', 'Company')}")

                    st.divider()

        with tab2:
            # Detailed view with expandable sections
            for sponsor in st.session_state.sponsors:
                with st.expander(f"{sponsor['name']} - {sponsor['distance']:.1f}km"):
                    col1, col2 = st.columns(2)

                    with col1:
                        st.metric("Distance", f"{sponsor['distance']:.1f} km")
                        st.metric("Coordinates", f"{sponsor['lat']:.4f}, {sponsor['lon']:.4f}")

                    with col2:
                        st.metric("Match Score", f"{sponsor['score'] * 100:.0f}%")
                        st.button(
                            f"üìß Contact {sponsor['name']}",
                            key=f"detail_contact_{sponsor['id']}",
                            use_container_width=True
                        )


def render_map(selected_club, sponsors):
    """Render interactive map with club and sponsors."""

    # Default center on Gothenburg
    center_lat, center_lon = 57.7089, 11.9746
    zoom = 11

    # Center on selected club if available
    if selected_club and selected_club.get('lat') and selected_club.get('lon'):
        center_lat = float(selected_club['lat'])
        center_lon = float(selected_club['lon'])
        zoom = 12

    # Create map with colorful OpenStreetMap tiles
    m = folium.Map(
        location=[center_lat, center_lon],
        zoom_start=zoom,
        tiles='OpenStreetMap'  # More colorful than CartoDB
    )

    # Add club marker
    if selected_club and selected_club.get('lat') and selected_club.get('lon'):
        folium.Marker(
            location=[float(selected_club['lat']), float(selected_club['lon'])],
            popup=folium.Popup(
                f"<b>{selected_club['name']}</b><br>"
                f"Members: {selected_club.get('member_count', 'N/A')}<br>"
                f"{selected_club.get('address', '')}",
                max_width=300
            ),
            icon=folium.Icon(color='purple', icon='star', prefix='fa'),
            tooltip=selected_club['name']
        ).add_to(m)

        # Add a circle around the club to show search radius
        folium.Circle(
            location=[float(selected_club['lat']), float(selected_club['lon'])],
            radius=2000,  # 2km radius
            color='purple',
            fill=True,
            fillOpacity=0.1
        ).add_to(m)

    # Add sponsor markers
    if sponsors:
        for sponsor in sponsors:
            if sponsor.get('lat') and sponsor.get('lon'):
                # More vibrant colors based on match score
                if sponsor['score'] > 0.8:
                    color = 'darkgreen'
                    icon_color = 'white'
                elif sponsor['score'] > 0.7:
                    color = 'green'
                    icon_color = 'white'
                elif sponsor['score'] > 0.6:
                    color = 'lightgreen'
                    icon_color = 'black'
                elif sponsor['score'] > 0.5:
                    color = 'orange'
                    icon_color = 'white'
                elif sponsor['score'] > 0.4:
                    color = 'beige'
                    icon_color = 'black'
                else:
                    color = 'lightblue'
                    icon_color = 'black'

                # Add colored circle around high-match sponsors
                if sponsor['score'] > 0.7:
                    folium.Circle(
                        location=[float(sponsor['lat']), float(sponsor['lon'])],
                        radius=200,
                        color=color,
                        fill=True,
                        fillOpacity=0.3
                    ).add_to(m)

                folium.Marker(
                    location=[float(sponsor['lat']), float(sponsor['lon'])],
                    popup=folium.Popup(
                        f"<div style='width:200px'>"
                        f"<h4 style='color:black'>{sponsor['name']}</h4>"
                        f"<b>Distance:</b> {sponsor['distance']:.1f}km<br>"
                        f"<b>Match:</b> {sponsor['score'] * 100:.0f}%<br>"
                        f"<div style='background:{color};color:{icon_color};padding:5px;margin-top:5px;text-align:center;border-radius:5px'>"
                        f"{'Excellent Match!' if sponsor['score'] > 0.8 else 'Good Match' if sponsor['score'] > 0.6 else 'Potential Match'}"
                        f"</div>"
                        f"</div>",
                        max_width=250
                    ),
                    icon=folium.Icon(color=color, icon='briefcase' if sponsor['score'] > 0.7 else 'building',
                                     prefix='fa'),
                    tooltip=f"{sponsor['name']} ({sponsor['score'] * 100:.0f}% match)"
                ).add_to(m)

    # Display map
    st.subheader("üìç Interactive Map")

    # Try folium_static first (more reliable)
    try:
        folium_static(m, width=700, height=500)
    except:
        # Fallback to st_folium if static fails
        st_folium(m, height=500, width=None, returned_objects=["last_object_clicked"])


if __name__ == "__main__":
    render_search_page()


================================================================================
FIL: sponsor_match/core/config.py
================================================================================

import os
from pathlib import Path
from dotenv import load_dotenv
from urllib.parse import quote_plus

load_dotenv()

# Base directories
BASE_DIR = Path(__file__).parent.parent.resolve()
DATA_DIR = BASE_DIR / "data"
MODELS_DIR = BASE_DIR / "models"


# Database configuration - Fixed
def get_database_url():
    mysql_user = os.getenv("MYSQL_USER", "sponsor_user")
    mysql_password = os.getenv("MYSQL_PASSWORD", "Sports-2025?!")
    mysql_host = os.getenv("MYSQL_HOST", "localhost")
    mysql_port = os.getenv("MYSQL_PORT", "3306")
    mysql_db = os.getenv("MYSQL_DB", "sponsor_registry")

    # URL encode password to handle special characters
    encoded_password = quote_plus(mysql_password)

    return f"mysql+pymysql://{mysql_user}:{encoded_password}@{mysql_host}:{mysql_port}/{mysql_db}"


DATABASE_URL = get_database_url()

# App constants
APP_TITLE = os.getenv("APP_TITLE", "SponsorMatch AI")
LOGO_PATH = os.getenv("LOGO_PATH", str(BASE_DIR / "assets" / "logo.png"))
STREAMLIT_PAGE_ICON = "‚öΩ"

# Other settings
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
N_CLUSTERS = int(os.getenv("N_CLUSTERS", 5))
RANDOM_STATE = int(os.getenv("CLUSTER_RANDOM_STATE", 42))

================================================================================
FIL: sponsor_match/core/db.py
================================================================================

import logging

from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.exc import SQLAlchemyError

load_dotenv()
_engine = None


def get_engine():
    global _engine
    if _engine is None:
        # Get URL from config
        from sponsor_match.core.config import DATABASE_URL

        if not DATABASE_URL:
            raise RuntimeError("DATABASE_URL not configured")

        try:
            _engine = create_engine(
                DATABASE_URL,
                pool_size=5,
                max_overflow=10,
                pool_recycle=3600,
                pool_pre_ping=True,  # Test connections before use
                echo=False,
            )
            logging.info("Database engine created successfully")
        except SQLAlchemyError as e:
            logging.error(f"Failed to create database engine: {e}")
            raise
    return _engine


================================================================================
FIL: sponsor_match/core/logger.py
================================================================================

#!/usr/bin/env python3
"""
sponsor_match/core/logger.py
----------------------------
Utility to configure and retrieve named loggers, with console
and optional file handlers.
"""

import logging
import sys
from pathlib import Path

def setup_logger(
    name: str,
    log_file: Path | None = None,
    level: int = logging.INFO
) -> logging.Logger:
    """
    Return a logger configured with:
      - StreamHandler (stdout) at `level`
      - Optional FileHandler if `log_file` is provided
    """
    logger = logging.getLogger(name)
    if logger.handlers:
        # Already configured
        return logger

    logger.setLevel(level)
    fmt = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    formatter = logging.Formatter(fmt)

    console = logging.StreamHandler(sys.stdout)
    console.setLevel(level)
    console.setFormatter(formatter)
    logger.addHandler(console)

    if log_file:
        file_h = logging.FileHandler(log_file)
        file_h.setLevel(level)
        file_h.setFormatter(formatter)
        logger.addHandler(file_h)

    return logger


================================================================================
FIL: sponsor_match/ml/pipeline.py
================================================================================

import math
from pathlib import Path

import joblib
import pandas as pd
from sqlalchemy import text

from sponsor_match.core.db import get_engine

MODELS_DIR = Path(__file__).resolve().parents[2] / "models"
DEFAULT_KMEANS = MODELS_DIR / "kmeans.joblib"
LARGE_KMEANS = MODELS_DIR / "kmeans_large.joblib"


def haversine(lat1, lon1, lat2, lon2):
    """Compute great-circle distance (km) between two points."""
    R = 6371.0
    phi1, lam1, phi2, lam2 = map(math.radians, (lat1, lon1, lat2, lon2))
    dphi = phi2 - phi1
    dlam = lam2 - lam1
    a = (math.sin(dphi / 2) ** 2 +
         math.cos(phi1) * math.cos(phi2) * math.sin(dlam / 2) ** 2)
    return 2 * R * math.asin(math.sqrt(a))


def size_bucket_to_numeric(size_bucket):
    """Convert size bucket to numeric value."""
    mapping = {"small": 0, "medium": 1, "large": 2}
    return mapping.get(size_bucket, 1)


def load_models():
    """Load clustering models with error handling."""
    try:
        models = {}
        if DEFAULT_KMEANS.exists():
            models["default"] = joblib.load(DEFAULT_KMEANS)
        if LARGE_KMEANS.exists():
            models["large"] = joblib.load(LARGE_KMEANS)
        return models if models else None
    except Exception as e:
        print(f"Warning: Could not load models: {e}")
        return None


def safe_predict_cluster(model_data, features):
    """Safely predict cluster with new model format."""
    try:
        # Handle new model format (dict with scaler and kmeans)
        if isinstance(model_data, dict):
            scaler = model_data.get('scaler')
            kmeans = model_data.get('kmeans')

            if scaler and kmeans:
                # Scale features
                features_scaled = scaler.transform([features[:2]])  # Use only lat/lon
                # Predict cluster
                return kmeans.predict(features_scaled)[0]

        # Handle old model format (direct kmeans object)
        elif hasattr(model_data, 'predict'):
            # Check expected features
            expected_features = getattr(model_data, 'n_features_in_', None)
            if expected_features is None and hasattr(model_data, 'cluster_centers_'):
                expected_features = model_data.cluster_centers_.shape[1]

            if expected_features and len(features) != expected_features:
                print(f"Feature mismatch: model expects {expected_features}, got {len(features)}")
                # Pad or truncate features to match
                if len(features) < expected_features:
                    features = features + [0] * (expected_features - len(features))
                else:
                    features = features[:expected_features]

            return model_data.predict([features])[0]

    except Exception as e:
        print(f"Clustering prediction failed: {e}")
        return None


def score_and_rank(association_id, bucket, max_distance=50.0, top_n=10):
    """Score and rank potential sponsors with robust error handling."""
    engine = get_engine()

    try:
        with engine.connect() as conn:
            # Get association
            assoc_df = pd.read_sql(
                text("SELECT id,name,lat,lon,size_bucket,member_count FROM associations WHERE id=:i"),
                conn, params={"i": association_id}
            )

            # Get companies with all needed fields
            comps_df = pd.read_sql(
                "SELECT id,name,lat,lon,size_bucket,revenue_ksek,employees,industry FROM companies WHERE lat IS NOT NULL AND lon IS NOT NULL",
                conn
            )
    except Exception as e:
        print(f"Database error: {e}")
        return []

    if assoc_df.empty:
        return []

    club = assoc_df.iloc[0]

    # Load models
    models = load_models()
    club_cluster = None

    if models:
        model_key = "large" if bucket == "large" else "default"
        model = models.get(model_key)

        if model:
            # Prepare features (lat, lon)
            club_features = [club.lat, club.lon]
            club_cluster = safe_predict_cluster(model, club_features)

    recommendations = []
    for _, company in comps_df.iterrows():
        try:
            distance = haversine(club.lat, club.lon, company.lat, company.lon)
            if distance > max_distance:
                continue

            # Size matching bonus
            size_bonus = 1.2 if company.size_bucket == bucket else 1.0

            # Cluster matching bonus (if clustering worked)
            comp_cluster_bonus = 1.0
            if models and club_cluster is not None:
                model_key = "large" if company.size_bucket == "large" else "default"
                model = models.get(model_key)
                if model:
                    comp_features = [company.lat, company.lon]
                    comp_cluster = safe_predict_cluster(model, comp_features)
                    if comp_cluster is not None and comp_cluster == club_cluster:
                        comp_cluster_bonus = 1.3

            # Calculate final score
            score = (1.0 / (1.0 + distance)) * size_bonus * comp_cluster_bonus

            recommendations.append({
                "id": int(company.id),
                "name": str(company['name']),  # Fix: use column access instead of attribute
                "lat": float(company.lat),
                "lon": float(company.lon),
                "distance": round(distance, 2),
                "score": round(score, 3)
            })

        except Exception as e:
            print(f"Error processing company {company.get('name', 'unknown')}: {e}")
            continue

    # Sort by score and return top N
    recommendations.sort(key=lambda x: x["score"], reverse=True)
    return recommendations[:top_n]


